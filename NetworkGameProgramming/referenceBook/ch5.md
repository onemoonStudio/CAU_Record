# TCP 기반 서버 클라이언트 2

## TCP의 이론적인 이야기

### TCP 소켓에 존재하는 입출력 버퍼

- TCP에서 데이터의 전송은 경계가 없다
- 그렇다면 40바이트를 전달한 경우 10바이트만 읽었다면 나머지 30바이트는?
    - 소켓이 생성될 때 마다 각각 입출력 버퍼를 가진다.
    - 여기에서 read / write 가 호출 될 때 마다 데이터를 가져오고 쓴다.
    - 소켓을 닫아도 출력버퍼에 남아있는 데이터는 계속 전송이 이루어진다.
    - 하지만 소켓이 닫히면 입력버퍼에 남아있는 데이터는 사라진다.
- 입력버퍼의 크기를 초과하는 분량의 데이터 전송은 발생하지 않는다.
    - 이는 TCP에서 슬라이딩 윈도우(sliding window) 라는 프로토콜이 존재하고 이 
    프로토콜이 입출력 버퍼를 지속적으로 확인하면서 데이터를 송수신한다.

### TCP 내부 동작원리 1 : 상대 소켓과의 연결 

- Three Way handshaking 
    - [shake 1] A : 전달할 데이터가 있다. 연결을 요청한다.
        - [SYN] : SEQ : 1000    
    - [shake 2] B : 알겠다. 나도 지금 준비가 되었으니 언제든지 시작해도 좋다.
        - [SYN + ACK] : SEQ : 2000 , ACK : 1001
    - [shake 1] A : 알겠다.
        - [ACK] : SEQ : 1001 , ACK : 2001 
- [SYN]
    - synchornization 의 줄임말 으로서 , 데이터 송수신에 앞서 전송되는 동기화 메세지이다.
    - SEQ로 표현이 된다. 
    - SEQ : N 을 상대 소켓으로 보내면 돌아오는 ACK 는 N+1 이 되어야 한다.
- [ACK]
    - 응답 메세지이다.
    - ACK : N+1 이라고 하면 방금 전송한 SEQ : N 은 잘 받았으니, 다음에는 SYN : N+1 을 전송하길 바란다. 라는 뜻이다.
- [SYN + ACK]
    - 소켓은 전 이중방식으로 동작하므로 양방향으로 데이터를 주고 받을 수 있다.
    - 요청 메시지와 응답 메시지가 동시에 있는 경우를 말한다.

### TCP 내부 동작원리 2 : 상대 소켓과의 데이터 송수신

- Three way handshaking 을 통해 데이터 송수신 준비가 끝난 이후의 과정
- ACK 번호 => SEQ 번호 + 전송된 바이트 크기 + 1
- 예를 들어 호스트 A가 호스트 B에게 200 바이트를 두번에 걸쳐 보낸다고 생각하자 
    - A => B : SEQ 1200 [100 bytes]
    - B => A : ACK 1301 
    - A => B : SEQ 1301 [100 bytes]
    - B => A : ACK 1402 
- 만약 중간에 데이터가 패킷이 소멸될 경우 (위에서 2번째 단계까지만 갔다고 생각하자)    
   - ACK 를 보낸 후 타이머를 작동시키는데 이 타이머의 시간동안 SEQ가 오지 않으면 Time out 이 걸리고, A 에서 다시 SEQ 1301 그리고 [100 bytes]를 가진 패킷을 보내도록 요청한다.

### TCP 내부 동작원리 3 : 상대 소켓과의 연결종료

- 연결 종료 과정
    - A : 연결을 끝내고자 합니다.
    - B : 알겠습니다. 잠시만 기다려 주세요 !
    - B : 저도 준비가 끝났습니다. 연결을 끊어도 괜찮습니다.
    - A : 알겠습니다 연결을 끊겠습니다.
- Four-way handshaking 이다
    - FIN 메세지를 서로 주고 받는다
    - A에서 먼저 보내고 B에서 준비가 끝났다면 FIN 을 보낸다.
    - 이로서 연결이 종료된다.
    